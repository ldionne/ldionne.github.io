---
layout: post
title: "The quest for a perfect tuple: Prelude"
comments: true
tags: tuple metaprogramming
series: "The quest for a perfect tuple"
---

This post is a prelude to a series of posts I wish to write on an ambitious
subject; tuples. Some programming languages implement tuples at the language
level (Haskell, OCaml), while others implement them at the library level
(C#, D). In C++, tuples are implemented at the library level with types like
`std::tuple` or `boost::tuple`. You might not be aware of it, but the
implementation of tuples at the library level is an active area of research
for a number of (admittedly fairly specialized) C++ library writers. My quest
in this series is to explore this area of C++.

<!-- {% include series.html %} -->

At its heart, a tuple is a very simple thing. However, as we will see throughout
this series, different implementations can vary wildly both in complexity and
in quality. In order for us to judge whether an implementation is _better_ than
another, we'll need some criteria. But what can make a tuple better than another
one? Here's what we'll use:

1. Compile-time efficiency

   Some implementations might involve heavy metaprogramming, in which case the
   compile-times could go up drastically. While this might not be such a large
   problem for application developers, tuples are our most basic tool for
   metaprogramming. Hence, there is a large class of libraries that are built
   on top of tuples, or that at least use them internally (sometimes quite
   intensely). If tuples don't scale at compile-time, these libraries become
   less usable for end users, and we're toast. Hence, a good tuple should be
   nice with the compiler.

2. Runtime efficiency

    If we want tuples to be truly useful, it should be possible to use them
    both in performance-critical code and elsewhere. This is especially true
    when considering the argument used above; it should be possible for
    performance-critical libraries to be built on top of tuples, which is
    only possible if tuples are efficient. Also, since a tuple is in essence
    just a `struct`, it would just be reasonable to ask that it has a
    comparable runtime efficiency. Hence, for example, it would be
    completely nuts to have a tuple that needs to allocate.

    Another very important aspect of this is the ability for the compiler to
    optimize code manipulating tuples. It is one thing to provide an implementation
    that is _theoretically_ perfect, but if it causes the compiler to generate
    shitty code because of some reason, that implementation is unfortunately
    not a good choice for real world programming. Of course, a bug should also
    probably be filed against the compiler.

3. Compression of empty objects

    A nice feature to have from a tuple implementation is the ability not to
    store anything for empty objects. Indeed, using some metaprogramming tricks,
    it is possible to implement a tuple in which empty objects do not take up
    any space. This is a nice space optimization, and an implementation that
    allows this to happen should be rated higher than one that doesn't.

4. `constexpr`-friendliness

    Ideally, we'd like to be able to use a tuple inside constant expressions.
    This restricts the operations that we can use inside an implementation,
    since we must stay `constexpr`-friendly. This is not the most important
    point, since anything written with `constexpr` can be done at the type-
    level, and chances are that you don't need your tuples to be `constexpr`
    as much as you think. However, this is still a nice-to-have.

Among the above points, you might notice that _being compatible with the
interface of `std::tuple`_ was omitted. Indeed, `std::tuple` is a huge beast,
and implementing it correctly is almost impossible. But worse, doing so in a
compile-time efficient way is totally out of question; there's just too
much metaprogramming involved. Its 18 constructors (no shit!) require the
whole world to be instantiated and some complex SFINAE to be evaluated, which
makes the compiler go crazy.

For this reason, I would generally discourage the author of a core library to
use `std::tuple` as a building block. However, since this series is largely
targeted towards library writers, I will not consider being compatible with
`std::tuple` a goal towards we should strive _in this series_. Also note that
the vast majority of the time, you would get away with a tuple having a much
smaller interface, so sticking to `std::tuple` is by no means a _must have_.

Stay tuned for the next post in this series, where we'll take a look at the
current state of the art for implementing tuples.
