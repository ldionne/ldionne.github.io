---
layout: post
title: "The quest for a perfect tuple: Lambdas"
comments: true
tags: tuple metaprogramming
series: "The quest for a perfect tuple"
---

Back in June 2014, I posted an alternative implementation of `std::tuple` on
the [Boost.Devel][original-post] mailing list. In essence, the idea behind the
technique was to use a lambda as a fast compiler-generated closure whose
captured members were the members of the tuple. Along with a suitable way of
retrieving those members, this represented an interesting way of implementing
`std::tuple`, which is known to be quite heavy on the compiler. The goal of
this post is to explain this implementation technique for those not familiar
with it.

{% include series.html %}

Here is the gist of the technique:

{% highlight c++ %}
template <typename ...T>
auto make_storage(T&& ...t) {
    return [=](auto const& f) -> decltype(auto) { return f(t...); };
}

template <typename ...T>
struct tuple {
    using Storage = decltype(make_storage(std::declval<T>()...));
    Storage storage_;

    explicit tuple(T const& ...t)
        : storage_(make_storage(t...))
    { }
};
{% endhighlight %}

As you can see, the idea is to use the capture of the lambda as a _variadic_
struct generated by the compiler. By passing a function to that lambda, we
get an access to the unpacked representation of those members and we can
then apply any algorithm on parameter packs:

{% highlight c++ %}
template <typename Tuple>
auto front(Tuple tuple) {
    return tuple.storage_([](auto first, auto ...rest) {
        return first;
    });
}

template <typename Tuple>
auto pop_front(Tuple tuple) {
    return tuple.storage_([](auto first, auto ...rest) {
        return make_tuple(rest...);
    });
}

template <typename Tuple>
auto length(Tuple tuple) {
    return tuple.storage_([](auto ...elements) {
        return sizeof...(elements);
    });
}

// etc...

// then, use it like
tuple<int, char, double> ts{1, '2', 3.3};
assert(front(ts) == 1);
assert(length(ts) == 3);
{% endhighlight %}

> Note that I voluntarily left all usage of references and other possible
> optimizations out of the above to simplify the presentation.

The hope was that since there's no template metaprogramming behind this, the
compile-times should be better than with previously known techniques. We'll
see whether this is true at the end of the series, but for now let's
acknowledge some drawbacks of this technique.

First, since lambdas can't be made constexpr, this tuple can't either. However,
this is both a temporary situation ([P0170R0][] was accepted in Kona) and one
that we can live with most of the time. From my experience, `constexpr`-ness
is actually not so terribly useful for tuples.

Secondly, with the current rules for lambda capture lists, it is not possible
to construct the elements of the closure by perfect-forwarding arbitrary
arguments. Indeed, the only choices we have when creating the tuple above are
the following:

{% highlight c++ %}
template <typename ...T>
auto make_storage(T&& ...t) {
    return [=](auto f) { return f(t...); };
    // or
    return [&](auto f) { return f(t...); };
}
{% endhighlight %}

Obviously, we don't want to capture by reference, since we'll be returning a
tuple that contains potentially-dangling references. On the other hand, when
using `[=]` to capture by value, a _copy construction_ is made instead of
perfectly forwarding the corresponding `t` from the arguments. What we'd
really like is something like

{% highlight c++ %}
template <typename ...T>
auto make_storage(T&& ...t) {
    return [t_(std::forward<T>(t))...](auto f) { return f(t_...); };
}
{% endhighlight %}

but unfortunately this is not valid C++. And even then, we'd be missing some
functionality. Indeed, when the tuple is an rvalue, we would like to call the
`f` function with rvalue references to our elements. This way, the function
could decide to move the elements out if it needs to. However, it is not
possible to specify the rvalue-ness of `*this` for the lambda's `operator()`.

Thirdly, we do not have control over the storage of empty objects, since
everything is in the hands of the compiler. This could be both very good if
the compiler is clever, or very bad if it isn't. However, I don't think
anything in the standard would prevent the compiler from optimizing away
empty objects captured by a lambda. If so, it would be nice to see compilers
perform this optimization.

With this in mind, let's now implement a function to get the n-th element of
such a tuple. For this, we'll use a `nth_element` metafunction for getting the
n-th type of a parameter pack, as presented in [a previous post][pack-indexing]:

{% highlight c++ %}
template <std::size_t n, typename ...T>
decltype(auto) get(tuple<T...> const& ts) {
    using Nth = typename nth_element<n, T...>::type;
    return ts.storage_([](auto const& ...t) -> Nth const& {
        void const* addresses[] = {&t...};
        return *static_cast<Nth const*>(addresses[n]);
    });
}
{% endhighlight %}

How does it work? First, we get the type of the n-th element using a
metafunction. Then, we call the tuple's `storage_` (which is a lambda)
with another lambda that retrieves the n-th element of a parameter pack.
Here, the parameter pack is simply an expanded representation of the members
of the tuple. Finally, to retrieve the n-th element of that parameter pack,
we use array indexing with a bit of casting magic, and we're done. Some of
you might think that creating a temporary array of pointers to achieve this
is crazy, but we should really expect everything to be optimized away; we'll
confirm this with benchmarks in a later post.

Ok, so getting the n-th element of the tuple was quite easy. But one nice
advantage of this representation is the triviality of writing some slightly
more complex algorithms. For example, to implement a function equivalent to
a binary `std::tuple_cat`, one simple needs to unpack the two tuples and
create a new one:

{% highlight c++ %}
template <typename Xs, typename Ys>
auto concat(Xs&& xs, Ys&& ys) {
    return static_cast<Xs&&>(xs).storage_([&](auto&& ...xs_) {
        return static_cast<Ys&&>(ys).storage_([&](auto&& ...ys_) {
            return lambda::make_tuple(
                static_cast<decltype(xs_)&&>(xs_)...,
                static_cast<decltype(ys_)&&>(ys_)...
            );
        });
    });
}
{% endhighlight %}

Based on the same principle, one can then easily build other algorithms to
prepend or append elements, for example. Of course, some algorithms are not
simplified by this representation, too, but in most cases this is quite
flexible.


## Conclusion

In this post, we have seen how C++14 generic lambdas can be used to implement
a tuple by using the closure of the lambda in a clever way. We have also
explored an interesting way to index into a parameter pack using a local
array of pointers. These techniques have some drawbacks, but we also have
great hopes for them since almost everything is put in the hands of the
compiler, and the compile-time and runtime performance could theoretically
be quite good.

Stay tuned for the next post, where we'll explore another promising
implementation technique!


<!-- Links -->
[original-post]: http://lists.boost.org/Archives/boost/2014/06/214213.php
[P0170R0]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0170r0.pdf
[pack-indexing]: {% post_url 2015-11-29-efficient-parameter-pack-indexing %}
