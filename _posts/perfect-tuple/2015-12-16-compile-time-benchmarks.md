---
layout: post
title: "The quest for a perfect tuple: Compile-time benchmarks"
comments: true
tags: tuple metaprogramming
series: "The quest for a perfect tuple"
charts: true
---

In the previous posts of this series, we've seen a few techniques for
implementing a tuple at the library level. In the [prelude][] to the
series, I highlighted how important compile-time performance could be
for a tuple implementation. Now's the time to get serious and see how
the techniques we've explored fare in this respect.

{% include series.html %}


## Creating tuples

We'll compare the tuple implementations on several aspects. First, we'll want
to measure the sheer cost of instantiating tuples for each implementation.
More specifically, we'll want to measure how well an implementation scales
in terms of the size of the tuple created, and how well it scales in terms
of the number of tuples instantiated (given a fixed tuple size). For the
first aspect, our benchmark code will look like this:

{% highlight c++ %}
template <int i>
struct x { };

int main() {
    tuple<x1<0>, x1<1>, ..., x1<n>> t1;
    tuple<x2<0>, x2<1>, ..., x2<n>> t2;
    ...
    tuple<x10<0>, x10<1>, ..., x10<n>> t10;
}
{% endhighlight %}

The methodology is simply to measure the compile-time of such a file for various
values of `n`. The reason why we instantiate 10 different tuples every time is
that it reduces the relative incertitude on the measurement. We're almost ready
to look at the result, but before we do, let's pick a baseline to compare all
implementations against:

{% highlight c++ %}
template <typename ...T>
struct tuple {
    static constexpr std::size_t sizes[] = {sizeof(T)...};
};
{% endhighlight %}

This baseline is obviously not a valid tuple, but measuring it will still
allow us to factor out some noise such as compiler startup time. Because
of the `sizes` array, this will also allow us to factor out the cost of
instantiating the elements of the tuple themselves. Here's a chart
showing the results:

<!-- ninja -C _code/build tuple-quest.make_compile1 -->
<div class="chart" style="width:100%; height:400px;">
{
    "title": {
        "text": "Compile-time behavior of creating a tuple of length n"
    },
    "xAxis": {
        "title": { "text": "Size of the tuple" }
    },
    "series": [
        {
            "name": "atoms",
            "data": [[0, 0.32252791500650346], [10, 0.37476304097799584], [20, 0.40131123299943283], [30, 0.4464209059951827], [40, 0.4933795920223929], [50, 0.5875549199990928], [60, 0.6269187419675291], [70, 0.6898943550186232], [80, 0.8194551650085486], [90, 0.9071355229825713], [100, 1.0086682600085624], [110, 1.1469206880428828], [120, 1.2553649840410799], [130, 1.5358630630071275], [140, 1.5090981919784099], [150, 1.703226801007986], [160, 1.9030309419613332], [170, 1.967162771965377], [180, 2.213856263027992], [190, 2.436333558987826], [200, 2.9156332010170445], [210, 2.9746124299708754], [220, 3.126260496035684], [230, 3.410883233009372], [240, 3.6746486999909393], [250, 4.002902075997554], [260, 4.266632813960314], [270, 4.510958145954646], [280, 4.8864003959461115], [290, 5.1047923840233125], [300, 5.426421137002762]]
        }, {
            "name": "flat",
            "data": [[0, 0.3426869090180844], [10, 0.358175483008381], [20, 0.38664237497141585], [30, 0.3880674359970726], [40, 0.4023897360311821], [50, 0.4282817380153574], [60, 0.44382818799931556], [70, 0.48901676101377234], [80, 0.48097267298726365], [90, 0.5142624839791097], [100, 0.5294386360328645], [110, 0.5574877019971609], [120, 0.538554064987693], [130, 0.5688539200345986], [140, 0.5661929110065103], [150, 0.6144757879665121], [160, 0.6592116670217365], [170, 0.6111160799628124], [180, 0.6680068859714083], [190, 0.6932048629969358], [200, 0.710114841000177], [210, 0.7048033219762146], [220, 0.7328993339906447], [230, 0.7489577259984799], [240, 0.7632744809961878], [250, 0.7697581590036862], [260, 0.8236610610038042], [270, 0.8310004340019077], [280, 0.8514622179791331], [290, 0.9121377600240521], [300, 0.8761331599671394]]
        }, {
            "name": "lambda",
            "data": [[0, 0.35916333697969094], [10, 0.3542188929859549], [20, 0.360924502951093], [30, 0.3774650030536577], [40, 0.38515596801880747], [50, 0.3990820180042647], [60, 0.40237496903864667], [70, 0.42464519396889955], [80, 0.44028833403717726], [90, 0.4418806020403281], [100, 0.43640530202537775], [110, 0.48958910297369584], [120, 0.48019605700392276], [130, 0.5010298739653081], [140, 0.5194276419933885], [150, 0.5221460969769396], [160, 0.5893203769810498], [170, 0.5393034800072201], [180, 0.5595953000010923], [190, 0.5605739160091616], [200, 0.6040611749631353], [210, 0.5986734289908782], [220, 0.6234757879865356], [230, 0.6500606189947575], [240, 0.6535512219998054], [250, 0.6665206939796917], [260, 0.6623636920121498], [270, 0.6872610969585367], [280, 0.6978520390111953], [290, 0.7382150570047088], [300, 0.7456804409739561]]
        }, {
            "name": "raw",
            "data": [[0, 0.39647843496641144], [10, 0.40531287499470636], [20, 0.4327306060004048], [30, 0.4714528829790652], [40, 0.49422981298994273], [50, 0.5452678770525381], [60, 0.5611658780253492], [70, 0.6161174569861032], [80, 0.7048899739747867], [90, 0.6811408149660565], [100, 0.7162390029989183], [110, 0.7405208160053007], [120, 0.7742668830323964], [130, 0.8150688649620861], [140, 0.8327539499732666], [150, 0.9331928609753959], [160, 0.9347004469600506], [170, 0.983819246001076], [180, 1.030068173946347], [190, 1.0094882770208642], [200, 1.0962205489631742], [210, 1.1014806629973464], [220, 1.1320085949846543], [230, 1.3079516859725118], [240, 1.2573414299986325], [250, 1.2970958900405094], [260, 1.3795617740252055], [270, 1.3173578219721094], [280, 1.446785346022807], [290, 1.4529515340109356], [300, 1.4427411130163819]]
        }, {
            "name": "baseline",
            "data": [[0, 0.3173864139826037], [10, 0.3448701009619981], [20, 0.35208114504348487], [30, 0.37898143799975514], [40, 0.34651065099751577], [50, 0.3599465360166505], [60, 0.3302134340046905], [70, 0.34170529595576227], [80, 0.35899486002745107], [90, 0.3350345470244065], [100, 0.3485674600233324], [110, 0.35728356504114345], [120, 0.3613241080311127], [130, 0.3543877280317247], [140, 0.366135440999642], [150, 0.36144322698237374], [160, 0.37152078200597316], [170, 0.3571894229971804], [180, 0.3637265790021047], [190, 0.3627612999989651], [200, 0.3734770200098865], [210, 0.36942556098802015], [220, 0.36978211399400607], [230, 0.36887982103507966], [240, 0.36594226001761854], [250, 0.37561082700267434], [260, 0.3829635260044597], [270, 0.37613581598270684], [280, 0.3821433869889006], [290, 0.3909721000236459], [300, 0.3858391069807112]]
        }
    ]
}
</div>

As we can see, the first implementation, which used recursive atoms, is by far
the worse one. This is probably due to the deeply nested instantiations, or to
the fact that the symbols can grow incredibly long. Indeed, for the first
implementation, we get something like:

{% highlight c++ %}
tuple<T1, T2, ..., Tn>
tuple<T2, ..., Tn>
...
tuple<Tn>
{% endhighlight %}

whereas for the second implementation, we only get

{% highlight c++ %}
tuple<T1, T2, ..., Tn>
tuple_impl<std::index_sequence<1, ..., n>, T1, T2, ..., Tn>
holder<1, T1>,
holder<2, T2>,
...
holder<n, Tn>
{% endhighlight %}

And we get even less for the other two implementations. The trick here is that
each `tuple<T1, ..., Tn>` can grow very, very large. Since the compiler has to
somehow store these symbols, it can really hurt compile-time performance. In
comparison, each  `holder` type is much shorter than a whole `tuple<T1, ..., Tn>`
type, since it only contains one type.

Regarding the lambda-based technique; this seems pretty good, but perhaps not
as good as we would have expected. Indeed, if you click on the `atoms` curve
in the chart to zoom on the other curves, you'll see that both the `flat`
implementation and the `lambda` implementation seem linear. This is a bit
surprising, because the `lambda` implementation requires a constant number
of instantiations, regardless of the size of the tuple. Hence, this must be
caused to something internal to the compiler, like a poor choice of data
structures and algorithms for implementing lambdas.

Finally, it turns out that the last approach using aligned storage does not
fare as well as we might have expected. Here, the only real explanation is
that `constexpr` evaluation is far from cheap.

OK; measuring the instantiation cost of large tuples is nice, but we'd also
like to know how the techniques scale with respect to the number of
different tuples created. To do this, we'll benchmark the following code:

{% highlight c++ %}
template <int i>
struct x { };

int main() {
    tuple<x<1>, x<2>, ..., x<10>> t1;
    tuple<x<2>, x<3>, ..., x<11>> t2;
    ...
    tuple<x<n>, x<n+1>, ..., x<n+10>> tn;
}
{% endhighlight %}

Here, we're arbitrarily setting what seems to be a sensible tuple size (`10`),
and then measuring the time required to instantiate `n` tuples of that size.
To make sure we're actually instantiating different tuple types, we shift the
types of the elements of each tuple by one. Here's the result:

<!-- ninja -C _code/build tuple-quest.make_compile2 -->
<div class="chart" style="width:100%; height:400px;">
{
    "title": {
        "text": "Compile-time behavior of creating n tuples"
    },
    "xAxis": {
        "title": { "text": "Number of tuples" }
    },
    "series": [
        {
            "name": "atoms",
            "data": [[0, 0.3031120580271818], [10, 0.3653895070310682], [20, 0.3663804469979368], [30, 0.4160121890017763], [40, 0.48540901800151914], [50, 0.4627230089972727], [60, 0.5016049690311775], [70, 0.5240902309888043], [80, 0.6763172719511203], [90, 0.6312445049989037], [100, 0.5739593970356509], [110, 0.8161111410008743], [120, 0.6685234369942918], [130, 0.687216994992923], [140, 0.6939177319873124], [150, 0.7567666880204342], [160, 0.7695203460170887], [170, 0.790973060997203], [180, 0.8090593600063585], [190, 0.8473627969506197], [200, 0.861952088016551], [210, 0.9241499800118618], [220, 0.9297847150010057], [230, 0.9293775880360045], [240, 0.9666079439921305], [250, 1.0096755369449966], [260, 1.0281325760297477], [270, 1.0731081779813394], [280, 1.0761376210139133], [290, 1.1271103780018166], [300, 1.1427464890293777], [310, 1.1736012870096602], [320, 1.283062532020267], [330, 1.3018969480181113], [340, 1.2870535270194523], [350, 1.287906554993242], [360, 1.3396281320019625], [370, 1.4118485749932006], [380, 1.3848495979909785], [390, 1.397247959044762], [400, 1.4028978670248762], [410, 1.4643996779923327], [420, 1.4600928179570474], [430, 1.4706959039904177], [440, 1.516849261999596], [450, 1.5531395740108564], [460, 1.5415422130026855], [470, 1.5580950480070896], [480, 1.6419800210278481], [490, 1.6143809199566022], [500, 1.6511281999992207], [510, 1.6897974150488153], [520, 1.7539129760116339], [530, 1.729574603959918], [540, 1.7476258620154113], [550, 1.7596089010476135], [560, 1.8188327830284834], [570, 1.806973465019837], [580, 1.8895473980228417], [590, 1.8508863700553775], [600, 1.920085659949109], [610, 1.9187599790166132], [620, 1.96463489998132], [630, 2.045713310013525], [640, 2.1547517760191113], [650, 2.041853467002511], [660, 2.060602924961131], [670, 2.0603292399900965], [680, 2.180070003028959], [690, 2.150757225987036], [700, 2.1556406739982776], [710, 2.2034219399793074], [720, 2.2149574200157076], [730, 2.219473010976799], [740, 2.259342950012069], [750, 2.3699592420016415], [760, 2.2791174600133672], [770, 2.4043478629901074], [780, 2.3755745860398747], [790, 2.3450493199634366], [800, 2.473180177039467], [810, 2.438572490995284], [820, 2.468189387000166], [830, 2.4874739289516583], [840, 2.543226151028648], [850, 2.6144432359724306], [860, 2.6147294939728454], [870, 2.5988590139895678], [880, 2.621091250970494], [890, 2.7830107850022614], [900, 2.7404620989691466], [910, 2.689856245997362], [920, 2.7983794530155137], [930, 2.8009829120128416], [940, 2.89835818100255], [950, 2.9801839170395397], [960, 2.9089086439926177], [970, 2.866982393024955], [980, 3.015905626001768], [990, 2.8851101450272836], [1000, 2.943300769024063]]
        }, {
            "name": "flat",
            "data": [[0, 0.3035969319753349], [10, 0.35280284099280834], [20, 0.3588720739935525], [30, 0.3718631910160184], [40, 0.3956142439856194], [50, 0.3982393640326336], [60, 0.44139183999504894], [70, 0.45461406698450446], [80, 0.48202635400230065], [90, 0.4746352629736066], [100, 0.5423542410135269], [110, 0.5323928029974923], [120, 0.5621551299700513], [130, 0.559556710999459], [140, 0.6444535960326903], [150, 0.6626547690248117], [160, 0.6788213399704546], [170, 0.7656754169729538], [180, 0.7094284429913387], [190, 0.6892591050127521], [200, 0.6974709029891528], [210, 0.7556893500150181], [220, 0.7991317060077563], [230, 0.8533393280231394], [240, 0.807190315972548], [250, 0.838762523024343], [260, 0.8401586819672957], [270, 0.8319102219538763], [280, 0.8774487859918736], [290, 0.9516298790113069], [300, 0.9398129060282372], [310, 0.8982577819842845], [320, 1.180792201019358], [330, 1.2335528330295347], [340, 0.9986743129556999], [350, 1.0898916290025227], [360, 1.1732244660379365], [370, 1.0598818520084023], [380, 1.304743446991779], [390, 1.2769993990077637], [400, 1.294550629972946], [410, 1.50194696104154], [420, 1.4188909910153598], [430, 1.392025517008733], [440, 1.2157786570023745], [450, 1.404339083994273], [460, 1.6086456860066392], [470, 1.7083140799659304], [480, 1.4177558480296284], [490, 1.4774268199689686], [500, 1.389347501040902], [510, 1.4276473129866645], [520, 1.4336227519670501], [530, 1.419385313987732], [540, 1.5613418080029078], [550, 1.4271076160366647], [560, 1.5823311380227096], [570, 1.6041379399830475], [580, 1.513132955005858], [590, 1.5117247099988163], [600, 1.5483277209568769], [610, 1.5631152130081318], [620, 1.5715593489585444], [630, 1.8973186610382982], [640, 1.7811646750196815], [650, 1.6139253129949793], [660, 1.7497029490186833], [670, 1.7307081070030108], [680, 1.7130129940342158], [690, 1.778794784040656], [700, 1.7225619929959066], [710, 1.753444944974035], [720, 1.8295395519817248], [730, 1.7550852840067819], [740, 1.8402185029699467], [750, 1.8081976710236631], [760, 1.8896475799847394], [770, 1.8668197999941185], [780, 2.852976612979546], [790, 2.14426937996177], [800, 2.513280968007166], [810, 2.655171369027812], [820, 2.1439982659649104], [830, 1.9881334459641948], [840, 2.0270148999989033], [850, 2.003310107975267], [860, 2.056692822952755], [870, 2.0623525209957734], [880, 2.168682110030204], [890, 2.2070061559788883], [900, 2.2365920119918883], [910, 2.3100736209889874], [920, 2.2451202520169318], [930, 2.4892667249660008], [940, 2.2557132429792546], [950, 2.278759097040165], [960, 2.3519169279607013], [970, 2.3015326560125686], [980, 2.361248436034657], [990, 2.318474013998639], [1000, 2.320779369038064]]
        }, {
            "name": "lambda",
            "data": [[0, 0.3441256089718081], [10, 0.3511610639980063], [20, 0.39308662101393566], [30, 0.4012260780436918], [40, 0.4020239109522663], [50, 0.4299183270195499], [60, 0.43485935701755807], [70, 0.49502528802258894], [80, 0.48077742097666487], [90, 0.5053751349914819], [100, 0.5510877899941988], [110, 0.5347053210134618], [120, 0.5731442479882389], [130, 0.5672321420279332], [140, 0.5968136379960924], [150, 0.6534129809588194], [160, 0.6451792599982582], [170, 0.6303515909821726], [180, 0.6804201690247282], [190, 0.7232685399940237], [200, 0.7130926320096478], [210, 0.7530087440391071], [220, 0.7735321880318224], [230, 0.7836259010364302], [240, 0.7985900560161099], [250, 0.8081507009919733], [260, 0.8786494090454653], [270, 0.8741123469662853], [280, 0.8572499860310927], [290, 0.8840200689737685], [300, 0.932553177990485], [310, 0.9175646370276809], [320, 0.9436420379788615], [330, 0.9840669100522064], [340, 0.9872873789863661], [350, 0.983457873982843], [360, 1.0426519219763577], [370, 1.0844270780216902], [380, 1.0846617740462534], [390, 1.102413910033647], [400, 1.0770231079659425], [410, 1.1205041320063174], [420, 1.1497314909938723], [430, 1.1252650360111147], [440, 1.184030078991782], [450, 1.3008050749776885], [460, 1.3202391210361384], [470, 1.2480153299984522], [480, 1.2572390559944324], [490, 1.2787918549729511], [500, 1.3042291619931348], [510, 1.279450278962031], [520, 1.3057894270168617], [530, 1.383948796952609], [540, 1.3698713090270758], [550, 1.329166610026732], [560, 1.552260453987401], [570, 1.4013371960027143], [580, 1.4158815229893662], [590, 1.5316353020025417], [600, 2.1046954870107584], [610, 1.8566377920215018], [620, 1.933250367990695], [630, 1.8162022070027888], [640, 1.843475772999227], [650, 1.9445192890125327], [660, 1.7327730620163493], [670, 1.6793272059876472], [680, 1.8988589780055918], [690, 1.8170058079995215], [700, 1.8296584279742092], [710, 1.8965318709961139], [720, 1.8436384059605189], [730, 2.017964166996535], [740, 1.9933206959976815], [750, 1.9334912130143493], [760, 1.9699445290025324], [770, 1.8859156310209073], [780, 2.0362229930469766], [790, 1.994764162984211], [800, 2.039475853962358], [810, 2.03035012295004], [820, 2.0591151030384935], [830, 2.115204378031194], [840, 2.2473552209557965], [850, 2.1180992139852606], [860, 2.218063130043447], [870, 2.217459915962536], [880, 2.2678598479833454], [890, 2.3062951560132205], [900, 2.3789741739747114], [910, 2.2376463480177335], [920, 2.2324952710187063], [930, 2.2482266169972718], [940, 2.288378901022952], [950, 2.340436319995206], [960, 2.2420123710180633], [970, 2.34950387198478], [980, 2.290847897005733], [990, 2.394507601042278], [1000, 2.508553149004001]]
        }, {
            "name": "raw",
            "data": [[0, 0.27890708499762695], [10, 0.33488288700027624], [20, 0.3690219790005358], [30, 0.41125656299846014], [40, 0.44430759999886504], [50, 0.49777069900301285], [60, 0.5424811720004072], [70, 0.5901003100007074], [80, 0.6401785029993334], [90, 0.6762274899992917], [100, 0.7241466809973645], [110, 0.7636119820017484], [120, 0.8245961319989874], [130, 0.8654216110007837], [140, 0.9148482710006647], [150, 0.9533665420021862], [160, 1.0087556680009584], [170, 1.0518550169981609], [180, 1.0907079950011394], [190, 1.134925161000865], [200, 1.1877624839980854], [210, 1.2521263170019665], [220, 1.3054394300015701], [230, 1.3352907939988654], [240, 1.3683583370002452], [250, 1.444326001997979], [260, 1.4725441590016999], [270, 1.5334266950012534], [280, 1.5330142069979047], [290, 1.603426445999503], [300, 1.6703281129994139], [310, 1.7075063930024044], [320, 1.7508783709999989], [330, 1.7983822450005391], [340, 1.8360583610010508], [350, 1.8786375010022311], [360, 1.9178420299977006], [370, 1.9999132479970285], [380, 2.0282104930010973], [390, 2.098935447000258], [400, 2.1131429619999835], [410, 2.176856065998436], [420, 2.2469615420013724], [430, 2.2468892020006024], [440, 2.3291503789987473], [450, 2.3462466729979496], [460, 2.417692202998296], [470, 2.4634035639974172], [480, 2.7105012489992077], [490, 2.8295967069971084], [500, 3.074900807998347], [510, 3.288978953998594], [520, 2.714086056002998], [530, 2.71267717000228], [540, 2.9400955279998016], [550, 2.824563918999047], [560, 2.8357715860001917], [570, 2.9195038600009866], [580, 2.9546183069978724], [590, 3.0071231150031963], [600, 3.032472169998073], [610, 3.085620870002458], [620, 3.153890178000438], [630, 3.195935877996817], [640, 3.2877214639993326], [650, 3.2671473600021272], [660, 3.335294785996666], [670, 3.3767818339983933], [680, 3.3952488700015238], [690, 3.5742021709993423], [700, 3.728342906000762], [710, 3.5546870520011], [720, 3.61151055099981], [730, 3.6256892299970787], [740, 3.6983912409996265], [750, 3.7304735010002332], [760, 3.795854895000957], [770, 3.829722178998054], [780, 3.888167651999538], [790, 3.8874303709999367], [800, 3.9648481879994506], [810, 4.065877901000931], [820, 4.083523556000728], [830, 4.0949025789996085], [840, 4.144830159999401], [850, 4.238676372002374], [860, 4.259004101000755], [870, 4.289578824998898], [880, 4.386273167998297], [890, 4.377481633000571], [900, 4.425963574998605], [910, 4.502111595000315], [920, 4.559205327001109], [930, 4.584349157998076], [940, 4.655124042001262], [950, 4.727267428999767], [960, 4.730086310999468], [970, 4.780489323999063], [980, 4.799972411001363], [990, 4.852778886997839], [1000, 4.927963641999668]]
        }, {
            "name": "baseline",
            "data": [[0, 0.339961769990623], [10, 0.3317403080291115], [20, 0.34859660803340375], [30, 0.35557345900451764], [40, 0.3418363389791921], [50, 0.3859975960222073], [60, 0.33324928098591045], [70, 0.34088987100403756], [80, 0.3546873719897121], [90, 0.3655062449979596], [100, 0.3886123269912787], [110, 0.3565238149603829], [120, 0.3645397310028784], [130, 0.3796575710293837], [140, 0.3654494339716621], [150, 0.3654824969707988], [160, 0.3910401159664616], [170, 0.3837877929909155], [180, 0.36952036200091243], [190, 0.38688346702838317], [200, 0.39432710100663826], [210, 0.39895677496679127], [220, 0.3865940950345248], [230, 0.40775373799260706], [240, 0.3931310980115086], [250, 0.3820634000003338], [260, 0.40295062999939546], [270, 0.39897583797574043], [280, 0.4063293450162746], [290, 0.4220738990115933], [300, 0.4033049590070732], [310, 0.41226127598201856], [320, 0.4279181430465542], [330, 0.4477459369809367], [340, 0.4200506680062972], [350, 0.4478778539923951], [360, 0.4337574809906073], [370, 0.4184848179575056], [380, 0.4230365519761108], [390, 0.420814456010703], [400, 0.4431783679756336], [410, 0.45369356602896005], [420, 0.4492215330246836], [430, 0.4359656920423731], [440, 0.4562172410078347], [450, 0.4389222789905034], [460, 0.4714215449639596], [470, 0.45866704103536904], [480, 0.44705718103796244], [490, 0.4558724309899844], [500, 0.4568131620180793], [510, 0.4758070909883827], [520, 0.45399147301213816], [530, 0.46112434001406655], [540, 0.47063319699373096], [550, 0.46965623303549364], [560, 0.46198274998459965], [570, 0.521947311994154], [580, 0.47343422897392884], [590, 0.4890232650213875], [600, 0.5071831120294519], [610, 0.4954599749762565], [620, 0.4949009900446981], [630, 0.49250478303292766], [640, 0.48856463603442535], [650, 0.5193399239797145], [660, 0.4898098150151782], [670, 0.5035610710037872], [680, 0.5177035810193047], [690, 0.5040935500292107], [700, 0.5048389389994554], [710, 0.5247083660215139], [720, 0.5265502479742281], [730, 0.550859114038758], [740, 0.5126473440323025], [750, 0.5281792400055565], [760, 0.5285399770364165], [770, 0.516897686989978], [780, 0.5205814969958737], [790, 0.533727178000845], [800, 0.5278345469851047], [810, 0.5181446750066243], [820, 0.5464836829924025], [830, 0.5445926760439761], [840, 0.5445025290246122], [850, 0.5274145719595253], [860, 0.5748269410105422], [870, 0.5511641809716821], [880, 0.5504501039977185], [890, 0.5720450840308331], [900, 0.5523500379640609], [910, 0.5842247609980404], [920, 0.5223973130341619], [930, 0.5827394269872457], [940, 0.5471773630124517], [950, 0.593245875032153], [960, 0.5977135360008106], [970, 0.5742757769767195], [980, 0.6008248690050095], [990, 0.5718633940559812], [1000, 0.5727378409937955]]
        }
    ]
}
</div>

As we can see, all implementations perform in a similar fashion, except for
the last one using aligned storage, which is worse by a good amount. This is
most likely due to the fact that we have to compute the offset of every member
in the tuple, like for the previous benchmark. However, we have to carry out
this computation for each tuple from scratch, which is why this benchmark
amplifies the difference between this new implementation and the previous ones.

Also, a note regarding the `lambda` implementation. As expected, we see that
the time required to instantiate `n` tuples grows linearly as a function of `n`.
I must admit that I was disappointed by those results, however. Indeed, since
lambdas are a language construct, they are handled inside the compiler and I
would have expected to see a significant speedup over another approach. It
turns out that this is not the case, at least with Clang 3.7. Perhaps their
lambda implementation could be improved, or perhaps there is a limitation I
am not seeing here. In all cases, the lambda based implementation is no worse
than the flat implementation given in the previous post.

<!-- TODO: Embellish the above -->

## Accessing tuples

Now, creating tuples is fun, but accessing elements in a tuple is more fun.
Hence, we'll also want to measure how well our implementations scale when
accessing elements with the `get` function. Much like the previous benchmarks,
there are mainly two interesting access patterns we can benchmark. The first
one is to fix a tuple size, and to access varying numbers of elements inside
the tuple. This pattern can be measured with the following benchmark:

{% highlight c++ %}
template <int i>
struct x { };

int main() {
    tuple<x<0>, x<1>, ..., x<500>> t;
    get<0 * (500/n)>(t);
    get<1 * (500/n)>(t);
    ...
    get<n * (500/n)>(t);
}
{% endhighlight %}

Here, we arbitrarily set the size of the tuple to `500`, which is large enough,
and then access `n` elements inside the tuple. Note that the `n` elements that
we access are placed at constant intervals, and they are almost uniformly
distributed in the \\([1, 500]\\) interval. We do this to avoid accessing the
first (or last) `n` elements, which would favor an implementation where
accessing leading (or trailing) elements is faster. Also, while not shown
here, we actually create a tuple of each implementation and only access
elements of the implementation we're benchmarking. This is to factor out
the initial cost of creating the tuple, which varies between implementations.
Before we show the results, let's show the baseline that we'll use:

{% highlight c++ %}
template <std::size_t i, typename Tuple>
constexpr int get(Tuple const&) {
    return 0;
}
{% endhighlight %}

Again, this is obviously not a correct implementation of `get`, but it will at
least allow us to factor out the cost of instantiating the `get` function. Here
is the result:

<!-- ninja -C _code/build tuple-quest.get_compile1 -->
<div class="chart" style="width:100%; height:400px;">
{
    "title": {
        "text": "Compile-time behaviour of getting n elements in a tuple"
    },
    "xAxis": {
        "title": {
            "text": "Number of elements"
        },
        "minTickInterval": 1
    },
    "series": [
        {
            "name": "atoms",
            "data": [[1, 2.7430356850018143], [51, 19.080829823000386], [101, 33.69522942399999], [151, 53.777618243999314], [201, 65.26296033999824], [251, 56.87080646599861], [301, 79.05052655300096], [351, 104.25828618499872], [401, 133.1576100880011], [451, 164.38040564499897]]
        }, {
            "name": "flat",
            "data": [[1, 1.8168098329988425], [51, 1.7710727900011989], [101, 1.8380601889984973], [151, 1.8823173430027964], [201, 1.973657924998406], [251, 1.9703010929988523], [301, 2.029322365000553], [351, 2.066871686001832], [401, 2.1442172110000683], [451, 2.1901850509966607]]
        }, {
            "name": "lambda",
            "data": [[1, 1.8685033630026737], [51, 5.267690621996735], [101, 8.627902555999754], [151, 12.0284878090024], [201, 15.41184782900018], [251, 18.919195251997735], [301, 22.292875605999143], [351, 25.704862941998726], [401, 29.02978488699955], [451, 32.58061200799784]]
        }, {
            "name": "raw",
            "data": [[1, 1.7539839249984652], [51, 1.8423580929993477], [101, 1.930015428999468], [151, 2.0498096230003284], [201, 2.110180052000942], [251, 2.222543190997385], [301, 2.2967236880031123], [351, 2.423779778997414], [401, 2.4633245499971963], [451, 2.573305003999849]]
        }, {
            "name": "baseline",
            "data": [[1, 1.7749120709995623], [51, 1.7713077929984138], [101, 1.829411581999011], [151, 1.8837151599982462], [201, 1.91652816700298], [251, 1.964494175001164], [301, 2.0011897389995283], [351, 2.0330733400005556], [401, 2.0754479209972487], [451, 2.1292497419999563]]
        }
    ]
}
</div>

Here, we can see that the recursive tuple implementation is really, really awful.
Indeed, every time we want to get an element, we need to recurse down to that
element in our chain of base classes. In contrast, the flat tuple implementation
only requires instantiating a single function every time we get an element,
which makes it O(1).

Lambda
------
Ouch! For some reason, the lambda-based tuple fares very badly in this benchmark.
To find out why, let's recall the implementation of the `get` function for the
lambda-based tuple:

{% highlight c++ %}
template <std::size_t n, typename ...T>
decltype(auto) get(tuple<T...> const& ts) {
    using Nth = typename nth_element<n, T...>::type;
    return ts.storage_([](auto const& ...t) -> Nth const& {
        ...
    });
}
{% endhighlight %}

I found what the problem was by benchmarking several close variations of this
`get` function. As surprising as it may sound, the expensive step here is the
argument deduction required when calling the lambda with the contents of the
tuple. Unfortunately, this cannot really be avoided.



End Lambda
----------

The second access pattern that we might want to measure is to fix a number of
elements to access inside the tuple, and to let the indices of these elements
grow larger and larger. This access pattern can be measured with the following
benchmark:

{% highlight c++ %}
template <int i>
struct x { };

int main() {
    tuple<x<0>, x<1>, ..., x<500>> t;
    get<n>(t);
    get<n+1>(t);
    get<n+2>(t);
    get<n+3>(t);
    get<n+4>(t);
    get<n+5>(t);
    get<n+6>(t);
    get<n+7>(t);
    get<n+8>(t);
    get<n+9>(t);
}
{% endhighlight %}

Here, we decide to access exactly `10` elements in the tuple. We then let the
index of these elements vary. The result is:

<!-- ninja -C _code/build tuple-quest.get_compile2 -->
<div class="chart" style="width:100%; height:400px;">
{
    "title": {
        "text": "Compile-time behaviour of getting the n-th element of a tuple"
    },
    "xAxis": {
        "title": {
            "text": "Index"
        },
        "minTickInterval": 1
    },
    "series": [
        {
            "name": "atoms",
            "data": [[0, 1.9426959510019515], [50, 2.8110494120010117], [100, 3.670933094002976], [150, 4.405426904999331], [200, 5.076616256999841], [250, 5.58531480199963], [300, 6.079452178000793], [350, 6.581843496001966], [400, 7.850460663998092], [450, 8.305800688998715]]
        }, {
            "name": "flat",
            "data": [[0, 2.1213851860011346], [50, 2.1233816300009494], [100, 2.335437176996493], [150, 1.8210540569998557], [200, 1.8032461750008224], [250, 1.79683842400118], [300, 1.8372620909976831], [350, 2.699952344999474], [400, 2.4300092769990442], [450, 1.9091410359978909]]
        }, {
            "name": "lambda",
            "data": [[0, 2.6000535579987627], [50, 2.5576570030025323], [100, 2.52494384399688], [150, 2.5153333140006], [200, 2.651383052998426], [250, 2.810097503999714], [300, 3.1716439140000148], [350, 2.942021360999206], [400, 2.55844825800159], [450, 2.6762027940021653]]
        }, {
            "name": "raw",
            "data": [[0, 2.024895587001083], [50, 2.413926924000407], [100, 2.217254677998426], [150, 2.8058147330011707], [200, 2.3653872030008642], [250, 2.11893703700116], [300, 1.9743411710005603], [350, 1.955617126001016], [400, 2.0462598749982135], [450, 2.0735046560002957]]
        }, {
            "name": "baseline",
            "data": [[0, 2.0268621840004926], [50, 1.9655956659989897], [100, 2.0171332089994394], [150, 1.98518869200052], [200, 1.9271590069984086], [250, 1.8430860329972347], [300, 2.2936138969998865], [350, 2.1540698899989366], [400, 2.0894923609994294], [450, 1.899316942999576]]
        }
    ]
}
</div>

As expected, we can see that the recursive implementation is worse than the flat
implementation. Furthermore, whereas the index at which an element is accessed
does not seem to matter for the flat implementation, the recursive implementation
is slower when accessing elements near the end of the tuple. Again, this is
because the recursive implementation must walk the whole tuple up to the
requested index, whereas the flat implementation performs in O(1) no matter
the index.


Lambda
-------
Here, we can see that while the complexity of the lambda-based approach is
constant, it also incurs a non-negligible constant cost. Off the top of my
head, that could be because we're using a tuple with 500 elements, and the
lambda inside `get` has to be called with all of those 500 elements all the
time, regardless of the index at which we're fetching an element. Hence,
we're taking a hit for argument deduction on a function call with 500
arguments, which is non-negligible.


## Conclusion

<!-- TODO -->


<!-- Links -->
[prelude]: {% post_url perfect-tuple/2015-12-12-prelude %}
